// Підключаємо бібліотеку для розбиття даних отриманих СОМ-портом на складові.
// *** Бібліотеку можна завантажити в менеджері.
#include "GParser.h"
// Підключаємо бібліотеку для отимання даних з датчика DHT11.
#include "DHT.h"
// Визначаємо вивід підключений до DHT11.
#define DHTPIN 2
// Визнчаємо тип DHT датчика, як DHT11.
#define DHTTYPE DHT11
// Визнчаємо тип DHT датчика, як DHT11.
DHT dht(DHTPIN, DHTTYPE);
// Визначаємо глобальні змінні, що будуть передачатися серверу.
int LEDonArduON, CardioWave;
float R2 = 0, Humidity, Temperature, HIC;
// Визнчаємо тип DHT датчика, як DHT11.
void setup() {
  // Швидкість обміну за послідовним портом 115200 бод.
  Serial.begin(115200);
  // Встаноснюємо час очікування даних за послідовним портом у 1 мс.
  Serial.setTimeout(1);
  // Задаємо очікування даних, що надсилаються послідовним інфтерфесом.
  Serial.flush();
  // Встановлюємо 12 вивід Arduino UNO у ролі виходу, а 10 та 11,я к входи.
  pinMode(12, OUTPUT);
  pinMode(10, INPUT);
  pinMode(11, INPUT);
  // Запускаємо читання даних з датчика DHT11.
  dht.begin();
}
// Визначаємо функцію, що читатиме команди, які надходять через послідовний порт.
void SerialDataRead() {
  // Отримуємо кількість байт символів доступних для читання з послідовного інтерфейсу.
  // *** Є можливість збільшити швидкість читання за рахунок використання асинхронної бібліотеки.
  if (Serial.available()) {
    // Визначаємо буфера str, як char масив з 30 алфавітно-цифрових символів.
    char str[30];
    // Зчитуємо байти з буфера послідовного з'єднання до розділового знаку ";".
    // Інформацію поміщуємо у буфер str з максимальною ємністю у 30 символів.
    // Записуємо інформацію до буфера amount.    
    int amount = Serial.readBytesUntil(';', str, 30);
    // Усю інформацію, що не відповідає розміру буфера amount та знаходиться після ";" не читаємо.
    str[amount] = NULL;
    // Використовуємо бібліотеку "GParser.h", яка розбиває рядок str на під рядки за розділовим знаком ','.
    GParser data(str, ',');
    // Визначаємо кількість підрядків.
    int ints[5];
    // За допомогою буфера am отримуємо з String  даних Int дані.
    int am = data.parseInts(ints);
    // Визначаємо у ролі ключа значення з 0 підрядока.
    switch (ints[0]) {
      // Визначаємо значення ключі що більше 100 у ролі вхідних команд для Arduino UNO.
      // 100 ключ керує світлодіодом Arduino UNO.
      case 100:
        LEDindicator(ints[1]);
        break;
      // Якщо надходить 100 ключ, то Arduino UNO відправляє зняті дані у послідовний порт.
      case 101:
        // Викликання функції повідомлення.
        Message();
        break;
    }
  }
}
// Ініціалізація функції для керування світлодіодом, що є вихідним кодом для подальшої розробки.
void LEDindicator(int intser) {
  if (intser > 0) {
    digitalWrite(12, HIGH);
    LEDonArduON = intser;
  }
  else {
    digitalWrite(12, LOW);
    LEDonArduON = intser;
  }
}
// Ініціалізація функції виміру опору шкіри.
void LeatherResistance(){
  // Іініціалізація змінних функції.
  int Vin = 5;     
  float Vout = 0;   
  float R1 = 272;      
  int a2d_data=0;    
  float bufferLeather = 0;
  // Читання даних з аналогового входу 0. 
  a2d_data = analogRead(A0);
  // Фільтр даних 1023, оскільки опір частіше буде знаходитися на рівні 1023, що не несе інформації.
  if(a2d_data < 1023)
  {
    // Розрахунок опору шкіри, на основі отриманого значення АЦП.
    bufferLeather = a2d_data*Vin;
    Vout = bufferLeather/1024.0;
    bufferLeather = Vout/(Vin-Vout); 
    R2 = R1*bufferLeather;
  }
  else{R2 = 0;}
}
// Ініціалізація функції отримання кардіограми.
void Cardiogram() {
  // Встановлення умови відсутності високого рівня на обох цифрових виводах мікроконтролера, щоб можна було отримати аналогове значення.
  if ((digitalRead(10) == 1) || (digitalRead(11) == 1)) {
    CardioWave = 0;
  }
  // Якщо високого рівня немає, то відбувається читання з блоку кардіографа через аналоговий вивід 1.
  else {
    CardioWave = analogRead(A1);
  }
  // Встановлення затримки у 1 мс, щоб данні встигали оброблятися.
  delay(1);
}
// Ініціалізація функції визначення параметрів подиху.
void Breathe(){
  // Читання параметрів вологості з датчика DHT11.
  Humidity = dht.readHumidity();
  // Читання температури з датчика DHT11.
  Temperature = dht.readTemperature();
  // Повернення, якщо дані не були визначені.
  if (isnan(Humidity) || isnan(Temperature)) {
    return;
  }
  // Розразунок коефіцієнта відношення температури-вологості.
  HIC = dht.computeHeatIndex(Temperature, Humidity, false);
}
// Ініціалізація функції посилки даних до сервера через послідовний порт.
void Message(){
  Serial.println("10," + String(R2) + ',' + String(CardioWave) + ',' + String(Humidity) + ',' + String(Temperature) + ',' + String(HIC) + ';');
}
// Ініціалізація основного циклу програми, де відбувається послідовне очікування кодів керування та отримання даних з блоків обробки.
void loop() {
  SerialDataRead();
  LeatherResistance();
  Cardiogram();
  Breathe();
}
